<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wireframe Sphere</title>
<style>
  /* ====== TEMA ====== */
  :root{
    --bg-1:#000;          /* fondo base */
    --bg-2:#06140c;       /* tono verdoso */
    --accent:#2bff88;     /* verde neón para líneas */
  }

  /* ====== LAYOUT ====== */
  html,body{height:100%}
  body{
    margin:0;
    background: radial-gradient(1200px 600px at 20% -10%, var(--bg-2) 0%, #021007 60%, var(--bg-1) 100%);
    overflow:hidden;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  }

  /* Líneas/scanlines tipo CRT */
  .crt{
    position:fixed; inset:0; pointer-events:none;
    background:repeating-linear-gradient(0deg, rgba(43,255,136,.06), rgba(43,255,136,.06) 1px, transparent 1px, transparent 3px);
    mix-blend-mode: screen;
  }

  /* Grid muy sutil en el fondo */
  .grid{
    position:fixed; inset:0; pointer-events:none; opacity:.07;
    background:
      linear-gradient(90deg, #2bff88 1px, transparent 1px) 0 0/40px 40px,
      linear-gradient(#2bff88 1px, transparent 1px) 0 0/40px 40px;
    filter: blur(.3px);
  }

  /* Canvas de la esfera */
  #sphere{
    position:fixed; inset:0; width:100%; height:100%; display:block;
  }
</style>
</head>
<body>
  <canvas id="sphere"></canvas>
  <div class="grid"></div>
  <div class="crt"></div>

<script>
/* ============================================================
   Esfera wireframe en Canvas 2D — sin librerías
   Autor: tú :)  |  Ajusta parámetros en CONFIG
   ============================================================ */

(() => {
  const canvas = document.getElementById('sphere');
  const ctx = canvas.getContext('2d');

  /* --------- CONFIG --------- */
  const CONFIG = {
    latSteps: 16,        // líneas horizontales (paralelos)
    lonSteps: 24,        // líneas verticales (meridianos)
    lineWidth: 2,        // grosor de línea
    glow: 12,            // brillo (sombra)
    color: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(),
    spinX: 0.005,        // velocidad de giro en X
    spinY: 0.01,         // velocidad de giro en Y
    fov: 700,            // “distancia focal” para la perspectiva
    radiusRatio: 0.36,   // tamaño de la esfera relativo al lado corto
  };

  /* --------- SIZE / DPR --------- */
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resize(){
    const { innerWidth:w, innerHeight:h } = window;
    canvas.width  = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    canvas.style.width  = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0); // todas las medidas en CSS px
    radius = Math.min(w, h) * CONFIG.radiusRatio;
    cx = w/2; cy = h/2;
  }
  let cx=0, cy=0, radius=0;
  window.addEventListener('resize', resize, {passive:true});
  resize();

  /* --------- GEOMETRÍA DE LA ESFERA --------- */
  // Precomputamos una malla de puntos 3D en reposo (latitudes x longitudes)
  const base = [];
  for (let i=0; i<=CONFIG.latSteps; i++){
    const v = i/CONFIG.latSteps;
    const phi = (v * Math.PI) - Math.PI/2; // [-pi/2, pi/2]
    const ring = [];
    for (let j=0; j<=CONFIG.lonSteps; j++){
      const u = j/CONFIG.lonSteps;
      const theta = u * Math.PI*2;        // [0, 2pi]
      // Puntos unitarios
      const x = Math.cos(phi) * Math.cos(theta);
      const y = Math.sin(phi);
      const z = Math.cos(phi) * Math.sin(theta);
      ring.push({x,y,z});
    }
    base.push(ring);
  }

  /* --------- ROTACIONES 3D --------- */
  function rotY(p, a){
    const s = Math.sin(a), c = Math.cos(a);
    return { x: c*p.x + s*p.z, y: p.y, z: -s*p.x + c*p.z };
  }
  function rotX(p, a){
    const s = Math.sin(a), c = Math.cos(a);
    return { x: p.x, y: c*p.y - s*p.z, z: s*p.y + c*p.z };
  }

  /* --------- PROYECCIÓN PERSPECTIVA --------- */
  const camZ = 3; // cámara “frente” a la esfera (en radios)
  function project(p){ // p en radios de 1
    // Escalamos por radius
    const x = p.x * radius, y = p.y * radius, z = p.z * radius;
    const zCam = (camZ*radius) - z;
    const s = CONFIG.fov / zCam;
    return { x: cx + x*s, y: cy + y*s };
  }

  /* --------- DIBUJAR LÍNEAS --------- */
  function drawPolyline(points){
    if(points.length < 2) return;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for(let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
    ctx.stroke();
  }

  /* --------- LOOP --------- */
  let rx = 0, ry = 0;
  function frame(){
    // Fondo “ghost” para estela muy tenue
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);

    ctx.lineWidth = CONFIG.lineWidth;
    ctx.strokeStyle = CONFIG.color;
    ctx.shadowColor = CONFIG.color;
    ctx.shadowBlur = CONFIG.glow;

    // Rotamos ángulos
    rx += CONFIG.spinX;
    ry += CONFIG.spinY;

    // 1) Paralelos (latitudes)
    for (let i=0; i<base.length; i++){
      const ring = base[i];
      const pts = ring.map(p => project(rotY(rotX(p, rx), ry)));
      drawPolyline(pts);
    }

    // 2) Meridianos (longitudes) – conectar por índice a lo largo de latitudes
    for (let j=0; j<base[0].length; j++){
      const col = [];
      for (let i=0; i<base.length; i++){
        const p = base[i][j];
        col.push(project(rotY(rotX(p, rx), ry)));
      }
      drawPolyline(col);
    }

    // Limpieza de sombra (para que no afecte a futuro dibujo UI si lo agregas)
    ctx.shadowBlur = 0;

    requestAnimationFrame(frame);
  }
  frame();
})();
</script>
</body>
</html>
